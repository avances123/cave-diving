import { Options } from './Options';
import { DepthConverter, DepthConverterFactory } from './depth-converter';
import { Ceiling, EventsFactory, Events, Event } from './Profile';
import { Segment, Segments } from './Segments';
import { Time } from './Time';
import { AscentSpeeds } from './speeds';
import { Precision } from './precision';

/** all values in bar */
class PressureSegment {
    constructor(
        public startDepth: number,
        public endDepth: number
    ) { }

    public get minDepth(): number {
        return Math.min(this.startDepth, this.endDepth);
    }

    public get maxDepth(): number {
        return Math.max(this.startDepth, this.endDepth);
    }

    public get isDescent(): boolean {
        return this.startDepth < this.endDepth;
    }

    public get isFlat(): boolean {
        return this.startDepth === this.endDepth;
    }

    public get isAscent(): boolean {
        return this.startDepth > this.endDepth;
    }
}

class EventsContext {
    public events: Events = new Events();
    public speeds: AscentSpeeds;
    /** total duration in seconds at beginning of current segment */
    public elapsed = 0;
    public index = 0;
    public fixedMnd = true;
    private _mndBars = 0;

    constructor(private startAscentIndex: number, private profile: Segment[],
        public depthConverter: DepthConverter, public options: Options) {
        this.speeds = new AscentSpeeds(options);
        const segments = Segments.fromCollection(profile);
        this.speeds.markAverageDepth(segments);
        this._mndBars = depthConverter.toBar(options.maxEND);
    }

    public get previous(): Segment | null {
        if (this.index > 0) {
            return this.profile[this.index - 1];
        }

        return null;
    }

    public get isBeforeDecoAscent(): boolean {
        return this.index < this.startAscentIndex;
    }

    public get maxPpo(): number {
        if (this.isBeforeDecoAscent) {
            return this.options.maxPpO2;
        }

        return this.options.maxDecoPpO2;
    }

    public get current(): Segment {
        return this.profile[this.index];
    }

    public get switchingGas(): boolean {
        return !!this.previous && !this.current.gas.compositionEquals(this.previous.gas);
    }

    /** Tank is only assigned by user */
    public get switchingTank(): boolean {
        return !!this.previous && !!this.previous.tank && !!this.current.tank &&
               this.previous.tank !== this.current.tank;
    }

    /** Gets maximum narcotic depth in bars */
    public get maxMnd(): number {
        return this._mndBars;
    }

    /** For depth in bars calculates the current equivalent narcotic depth in bars */
    public gasEnd(depth: number): number {
        const gas = this.current.gas;
        const oxygenNarcotic = this.options.oxygenNarcotic;
        return gas.end(depth, oxygenNarcotic);
    }
}

/** Creates events from profile generated by the algorithm */
export class ProfileEvents {
    /** Generates events for calculated profile
     * @param startAscentIndex Number of segments from beginning to count as dive, later segments are considered as decompression ascent
     *                E.g. In case of simple profile with 3 segments, only the last one is ascent, so this value is 2.
     * @param profile Complete list profile segments as user defined + calculated ascent
     * @param options User options used to create the profile
     */
    public static fromProfile(startAscentIndex: number, profile: Segment[], ceilings: Ceiling[], options: Options): Events {
        const depthConverter = new DepthConverterFactory(options).create();
        const context = new EventsContext(startAscentIndex, profile, depthConverter, options);
        const ceilingContext = new BrokenCeilingContext(context.events);

        for (context.index = 0; context.index < profile.length; context.index++) {
            // nice to have calculate exact time and depth of the events, it is enough it happened
            const pressureSegment = this.toPressureSegment(context.current, depthConverter);
            this.addHighPpO2(context, pressureSegment);
            this.addLowPpO2(context, pressureSegment);
            this.addGasSwitch(context);
            this.addUserTankSwitch(context);
            this.addHighDescentSpeed(context);
            this.addHighAscentSpeed(context);
            this.addSwitchHighN2(context);
            this.addMndExceeded(context, pressureSegment);

            ceilingContext.assignSegment(context.current);
            ProfileEvents.addBrokenCeiling(ceilingContext, ceilings, context.current);

            context.elapsed += context.current.duration;
        }

        return context.events;
    }

    private static addHighAscentSpeed(context: EventsContext) {
        const current = context.current;
        // Prevent events generated by precise numbers, it is safe because segments are generated with higher precision
        // this doesn't happen for descent, because it is never automatically calculated
        let speed = Time.toSeconds(current.speed);
        speed = Precision.roundTwoDecimals(speed);

        // ascent speed is negative number
        if (-speed > context.speeds.ascent(current.startDepth)) {
            const event = EventsFactory.createHighAscentSpeed(context.elapsed, current.startDepth);
            context.events.add(event);
        }
    }

    private static addHighDescentSpeed(context: EventsContext) {
        const current = context.current;
        const speed = Time.toSeconds(current.speed);

        if (speed > context.options.descentSpeed) {
            const event = EventsFactory.createHighDescentSpeed(context.elapsed, current.startDepth);
            context.events.add(event);
        }
    }

    private static addGasSwitch(context: EventsContext): void {
        if (context.switchingGas) {
            const current = context.current;
            const event = EventsFactory.createGasSwitch(context.elapsed, current.startDepth, current.gas);
            context.events.add(event);
        }
    }

    private static addUserTankSwitch(context: EventsContext): void {
        if (context.switchingTank) {
            const current = context.current;
            const event = EventsFactory.createGasSwitch(context.elapsed, current.startDepth, current.gas);
            context.events.add(event);
        }
    }

    private static toPressureSegment(segment: Segment, depthConverter: DepthConverter) {
        const startPressure = depthConverter.toBar(segment.startDepth);
        const endPressure = depthConverter.toBar(segment.endDepth);
        return new PressureSegment(startPressure, endPressure);
    }

    private static addHighPpO2(context: EventsContext, segment: PressureSegment): void {
        // non user defined gas switches are never to high ppO2 - see gases.bestGas
        // otherwise we don't know which ppO2 level to use
        if (segment.isDescent || (context.isBeforeDecoAscent && context.switchingGas)) {
            const gasMod = context.current.gas.mod(context.maxPpo);

            if (segment.maxDepth > gasMod) {
                const highDepth = context.depthConverter.fromBar(gasMod);
                const event = EventsFactory.createHighPpO2(context.elapsed, highDepth);
                context.events.add(event);
            }
        }
    }

    private static addLowPpO2(context: EventsContext, segment: PressureSegment): void {
        const gasCeiling = context.current.gas.ceiling(context.depthConverter.surfacePressure);
        const shouldAdd = (segment.minDepth < gasCeiling && context.switchingGas) ||
            (segment.startDepth > gasCeiling && gasCeiling > segment.endDepth && segment.isAscent) ||
            // only at beginning of a dive
            (context.current.startDepth === 0 && segment.startDepth < gasCeiling && segment.isDescent);

        // only crossing the line or gas switch
        if (shouldAdd) {
            const lowDepth = context.depthConverter.fromBar(gasCeiling);
            const event = EventsFactory.createLowPpO2(context.elapsed, lowDepth);
            context.events.add(event);
        }
    }

    /** Check only user defined segments break ceiling, because we trust the algorithm never breaks ceiling */
    private static addBrokenCeiling(context: BrokenCeilingContext, ceilings: Ceiling[], segment: Segment): void {
        while (context.lastCeilingIndex < context.currentSegmentEndTime && context.lastCeilingIndex < ceilings.length - 1) {
            const ceiling = ceilings[context.lastCeilingIndex];
            context.lastCeilingIndex++;

            const ceilingOk = context.belowCeiling(ceiling, segment);
            if (!ceilingOk && context.fixedBrokenCeiling) {
                const event = EventsFactory.createBrokenCeiling(ceiling.time, ceiling.depth);
                context.events.add(event);
                context.fixedBrokenCeiling = false;
                break;
            }

            if(ceilingOk && !context.fixedBrokenCeiling) {
                context.fixedBrokenCeiling = true;
            }

            if (ceiling.time > context.currentSegmentEndTime) {
                break;
            }
        }
    }

    private static addSwitchHighN2(context: EventsContext): void {
        const current = context.current;
        const previous = context.previous;

        if (context.switchingGas && previous) {
            const deltaN2 = current.gas.fN2 - previous.gas.fN2;
            const deltaHe = current.gas.fHe - previous.gas.fHe;

            if (previous.gas.fHe > 0 && deltaN2 * 5 > -deltaHe) {
                const event = EventsFactory.createSwitchToHigherN2(context.elapsed, current.startDepth, current.gas);
                context.events.add(event);
            }
        }
    }

    private static addMndExceeded(context: EventsContext, pressureSegment: PressureSegment): void {
        const current = context.current;
        // we need to check both start and end, because next segment may use another gas
        const startEnd = context.gasEnd(pressureSegment.startDepth);

        if (context.maxMnd < startEnd  && context.fixedMnd) {
            this.addMndEvent(context, context.elapsed, current.startDepth);
        }

        const endEnd = context.gasEnd(pressureSegment.endDepth);
        if (context.maxMnd < endEnd && context.fixedMnd) {
            const timeStamp = context.elapsed + current.duration;
            this.addMndEvent(context, timeStamp, current.endDepth);
        }

        // we can add the event multiple times, only after it is fixed
        context.fixedMnd = endEnd <= context.maxMnd;
    }

    private static addMndEvent(context: EventsContext, timeStamp: number, depth: number): void {
        const gas = context.current.gas;
        const event = EventsFactory.createMaxEndExceeded(timeStamp, depth, gas);
        context.events.add(event);
        context.fixedMnd = true;
    }
}

class BrokenCeilingContext {
    public lastCeilingIndex = 0; // prevents search in past ceilings
    public currentSegmentStartTime = 0;
    public currentSegmentEndTime = 0;
    public fixedBrokenCeiling = true;

    constructor(public events: Events) {
    }

    public assignSegment(newSegment: Segment): void {
        this.currentSegmentStartTime = this.currentSegmentEndTime;
        this.currentSegmentEndTime = this.currentSegmentStartTime + newSegment.duration;
    }

    public belowCeiling(ceiling: Ceiling, segment: Segment): boolean {
        const duration = ceiling.time - this.currentSegmentStartTime;
        const diverDepth = segment.depthAt(duration);
        return diverDepth >= ceiling.depth;
    }
}
